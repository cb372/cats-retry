// When the user clicks on the search box, we want to toggle the search dropdown
function displayToggleSearch(e) {
  e.preventDefault();
  e.stopPropagation();

  closeDropdownSearch(e);
  
  if (idx === null) {
    console.log("Building search index...");
    prepareIdxAndDocMap();
    console.log("Search index built.");
  }
  const dropdown = document.querySelector("#search-dropdown-content");
  if (dropdown) {
    if (!dropdown.classList.contains("show")) {
      dropdown.classList.add("show");
    }
    document.addEventListener("click", closeDropdownSearch);
    document.addEventListener("keydown", searchOnKeyDown);
    document.addEventListener("keyup", searchOnKeyUp);
  }
}

//We want to prepare the index only after clicking the search bar
var idx = null
const docMap = new Map()

function prepareIdxAndDocMap() {
  const docs = [  
    {
      "title": "Adaptation",
      "url": "/cats-retry/docs/adaptation.html",
      "content": "Adaptation When faced with a failure or an error, stubbornly retrying the same action is not always useful. Sometimes you want to adapt to the situation and try a different action. cats-retry supports this kind of adaptation. When using any of the combinators, you pass in a result handler. This handler can inspect the result of the action (or the error that the action raised, depending on the combinator), perform any necessary logging, then decide what to do next: Stop, either because the result is a successful one, so there is no need to retry, or because the error was so bad it’s not worth retrying Continue, meaning to keep retrying, assuming the retry policy agrees to Adapt to a new action. This action will be used on subsequent retries. Example: DynamoDB batch write DynamoDB provides an API operation called BatchWriteItem for efficiently inserting/updating multiple DB records in bulk, across one or more DB tables. The input to this operation is a map with the table names as keys, and lists of write requests as values: Map( \"TableA\" -&gt; List( &lt;write item 1&gt;, &lt;write item 2&gt;, ... ), \"TableB\" -&gt; List( &lt;write item 3&gt;, &lt;write item 4&gt;, ... ) ) Executing a BatchWriteItem operation can result in partial failure: you attempted to write 10 records, 7 succeeded and 3 failed. In this case, you usually want to retry only the 3 items that failed. Writing the whole batch of 10 again would be wasteful. Of course, the second attempt to write the 3 failed items could also partially fail: perhaps 2 succceeded this time, but 1 item failed again. The DynamoDB API response helpfully contains a field called UnprocessedItems, which is a collection of all the failed write requests, in just the right format for sending in a subsequent BatchWriteItem request. So we want to iterate as follows: remaining items = the whole batch while size(remaining items) &gt; 0: 1. attempt to write all remaining items 2. remaining items = UnprocessedItems in the API response AWS strongly recommends using an exponential backoff algorithm to insert delays between the iterations of this loop, and we probably want to limit the total number of retries, so we don’t get stuck retrying forever in case of AWS issues. This sounds like a perfect use case for cats-retry! Let’s assume we have a Scala DynamoDB client that simply wraps the AWS Java SDK in Cats Effect IO: val ddbClient = util.DDBClient() and we have a helper method that turns a Java collection of write requests into a BatchWriteItemRequest: import software.amazon.awssdk.services.dynamodb.model.* import java.util.List as JList import java.util.Map as JMap def buildRequest(writeRequests: JMap[String, JList[WriteRequest]]): BatchWriteItemRequest = BatchWriteItemRequest.builder() .requestItems(writeRequests) .build() and a batch of write requests that we want to perform: // In a real application, this batch would not be empty! val writeRequests: JMap[String, JList[WriteRequest]] = JMap.of() Let’s define a result handler to encode the retry logic we wrote in pseudocode above: import cats.effect.IO import cats.effect.unsafe.implicits.global import retry.* val handler: ValueHandler[IO, BatchWriteItemResponse] = (response: BatchWriteItemResponse, details: RetryDetails) =&gt; if response.hasUnprocessedItems() then // build a new BatchWriteItemRequest to retry only the requests that failed val updatedRequest = buildRequest(response.unprocessedItems()) // adapt our action to execute the updated request next time val updatedAction = ddbClient.batchWriteItem(updatedRequest) IO.pure(HandlerDecision.Adapt(updatedAction)) else // all the write requests succeeded, so we are done IO.pure(HandlerDecision.Stop) We also need a retry policy. We’ll use exponential backoff, as recommended by AWS, and limit it to 5 retries: import RetryPolicies.* import scala.concurrent.duration.* val policy = limitRetries[IO](5) join exponentialBackoff[IO](10.milliseconds) Our initial action will attempt to write the entire batch: val initialRequest = buildRequest(writeRequests) val action = ddbClient.batchWriteItem(initialRequest) Now we have all the pieces we need to call retryingOnFailures: val io = retryingOnFailures(action)(policy, handler) To recap, executing this IO will: first attempt to execute the entire batch of write requests using BatchWriteItem retry on partial failure, adapting the action to retry only the failed write requests iterate until there are no more failed write requests retry up to 5 times, with an exponentially increasing delay between retries io.unsafeRunSync() // res0: Either[BatchWriteItemResponse, BatchWriteItemResponse] = Right( // value = BatchWriteItemResponse() // )"
    } ,    
    {
      "title": "Combinators",
      "url": "/cats-retry/docs/combinators.html",
      "content": "Combinators The library offers a few slightly different ways to wrap your operations with retries. Cheat sheet Combinator Context bound Handles retryingOnFailures Temporal Failures retryingOnErrors Temporal Errors retryingOnFailuresAndErrors Temporal Failures and errors More information on each combinator is provided below. The context bound for all the combinators is Cats Effect Temporal, because we need the ability to sleep between retries. This implies that your effect monad needs to be Cats Effect IO or something similar. Failures vs errors We make a distinction between “failures” and “errors”, which deserves some explanation. An action with type IO[HttpResponse], when executed, can result in one of three things: Success, meaning it returned an HTTP response that we are happy with, e.g. a 200 response Failure, meaning it returned an HTTP response but we are not happy with it, e.g. a 404 response Error, meaning it raised an exception, e.g. using IO.raiseError(...) cats-retry lets you choose whether you want to retry on failures, on errors, or both. Unrecoverable errors Some errors are worth retrying, while others are so serious that it’s not worth retrying. For example, if an HTTP request failed with a 500 response, it’s probably worth retrying, but if the server responded with a 401 Unauthorized, it’s probably not. Retrying the same request would just result in another 401 response. When an action raises an error, cats-retry lets you inspect the error and decide whether you want to retry or bail out. See the retryingOnErrors combinator for more details. retryingOnFailures To use retryingOnFailures, you pass in a value handler that decides whether you are happy with the result or you want to retry. The API looks like this: def retryingOnFailures[F[_]: Temporal, A]( action: F[A] )( policy: RetryPolicy[F], valueHandler: ValueHandler[F, A] ): F[Either[A, A]] The inputs are: the operation that you want to wrap with retries a retry policy, which determines the maximum number of retries and how long to delay after each attempt a handler that decides whether the operation was successful, and does any necessary logging The return value is one of: the successful value returned by the final attempt, wrapped in a Right(...) to indicate success the failed value returned by the final attempt before giving up, wrapped in a Left(...) to indicate failure an error raised in F, if either the action or the value handler raised an error Semantics Example For example, let’s keep rolling a die until we get a six, using IO. import cats.effect.IO import cats.effect.unsafe.implicits.global import retry.* import scala.concurrent.duration.* val loadedDie = util.LoadedDie(2, 5, 4, 1, 3, 2, 6) val io = retryingOnFailures(loadedDie.roll)( policy = RetryPolicies.constantDelay(10.milliseconds), valueHandler = (value: Int, details: RetryDetails) =&gt; value match case 6 =&gt; IO.pure(HandlerDecision.Stop) // successful result, stop retrying case failedValue =&gt; IO(println(s\"Rolled a $failedValue, retrying ...\")) .as(HandlerDecision.Continue) // keep trying, as long as the retry policy allows it ) io.unsafeRunSync() // Rolled a 2, retrying ... // Rolled a 5, retrying ... // Rolled a 4, retrying ... // Rolled a 1, retrying ... // Rolled a 3, retrying ... // Rolled a 2, retrying ... // res0: Either[Int, Int] = Right(value = 6) There is also a helper for lifting a predicate into a ValueHandler: val io = retryingOnFailures(loadedDie.roll)( policy = RetryPolicies.constantDelay(10.milliseconds), valueHandler = ResultHandler.retryUntilSuccessful(_ == 6, log = ResultHandler.noop) ) io.unsafeRunSync() // res1: Either[Int, Int] = Right(value = 6) retryingOnErrors This is useful when you want to retry on some or all errors raised in your effect monad’s error channel. To use retryingOnErrors, you pass in a handler that decides whether a given error is worth retrying. The API looks like this: def retryingOnErrors[F[_]: Temporal, A]( action: F[A] )( policy: RetryPolicy[F], errorHandler: ErrorHandler[F, A] ): F[A] The inputs are: the operation that you want to wrap with retries a retry policy, which determines the maximum number of retries and how long to delay after each attempt a handler that decides whether a given error is worth retrying, and does any necessary logging The return value is either: the value returned by the action, or an error raised in F, if the action raised an error that the error handler judged to be unrecoverable the action repeatedly raised errors and we ran out of retries the error handler raised an error Semantics Example For example, let’s make a request for a cat gif using our flaky HTTP client, retrying only if we get an IOException. import java.io.IOException val httpClient = util.FlakyHttpClient() val flakyRequest: IO[String] = httpClient.getCatGif val io = retryingOnErrors(flakyRequest)( policy = RetryPolicies.limitRetries(5), errorHandler = (e: Throwable, retryDetails: RetryDetails) =&gt; e match case _: IOException =&gt; IO.pure(HandlerDecision.Continue) // worth retrying case _ =&gt; IO.pure(HandlerDecision.Stop) // not worth retrying ) io.unsafeRunSync() // res2: String = \"cute cat gets sleepy and falls asleep\" There is also a helper for the common case where you want to retry on all errors: val io = retryingOnErrors(flakyRequest)( policy = RetryPolicies.limitRetries(5), errorHandler = ResultHandler.retryOnAllErrors(log = ResultHandler.noop) ) io.unsafeRunSync() // res3: String = \"cute cat gets sleepy and falls asleep\" retryingOnFailuresAndErrors This is a combination of retryingOnFailures and retryingOnErrors. It allows you to specify failure conditions for both the results and errors that can occur. To use retryingOnFailuresAndErrors, you need to pass in a handler that decides whether a given result is a success, a failure, an error that’s worth retrying, or an unrecoverable error. The API looks like this: def retryingOnFailuresAndErrors[F[_]: Temporal, A]( action: F[A] )( policy: RetryPolicy[F], errorOrValueHandler: ErrorOrValueHandler[F, A] ): F[Either[A, A]] The inputs are: the operation that you want to wrap with retries a retry policy, which determines the maximum number of retries and how long to delay after each attempt a handler that inspects the action’s return value or error and decides whether to retry, and does any necessary logging The return value is one of: the successful value returned by the final attempt, wrapped in a Right(...) to indicate success the failed value returned by the final attempt before giving up, wrapped in a Left(...) to indicate failure an error raised in F, if the action raised an error that the error handler judged to be unrecoverable the action repeatedly raised errors and we ran out of retries the error handler raised an error ErrorOrValueHandler Note that the behaviour of the ErrorOrValueHandler is quite subtle. The interpretation of its decision (a HandlerDecision) depends on whether the action returned a value or raised an error If the action returned a value, the handler will be given a Right(someValue) to inspect. If the handler decides the result of the action was successful, it should return Stop, meaning there is no need to keep retrying. cats-retry will stop retrying, and return the successful result. On the other hand, if the handler decides that action was not successful, it should return Continue, meaning the action has not succeeded yet so we should keep retrying. cats-retry will then consult the retry policy. If the policy agrees to keep retrying, cats-retry will do so. Otherwise it will return the failed value. If the action raised an error, the handler will be given a Left(someThrowable) to inspect. If the handler decides the error is worth retrying, it should return Continue. cats-retry will then consult the retry policy. If the policy agrees to keep retrying, cats-retry will do so. Otherwise it will re-raise the error. If the handler decides the error is not worth retrying, it should return Stop. cats-retry will re-raise the error. Semantics Example For example, let’s make a request to an API to retrieve details for a record, which we will only retry if: A timeout exception occurs The record’s details are incomplete pending future operations import java.util.concurrent.TimeoutException val httpClient = util.FlakyHttpClient() val flakyRequest: IO[String] = httpClient.getRecordDetails(\"foo\") val errorOrValueHandler: ErrorOrValueHandler[IO, String] = (result: Either[Throwable, String], retryDetails: RetryDetails) =&gt; result match case Left(_: TimeoutException) =&gt; IO.pure(HandlerDecision.Continue) // worth retrying case Left(_) =&gt; IO.pure(HandlerDecision.Stop) // not worth retrying case Right(\"pending\") =&gt; IO.pure(HandlerDecision.Continue) // failure, retry case Right(_) =&gt; IO.pure(HandlerDecision.Stop) // success val io = retryingOnFailuresAndErrors(flakyRequest)( policy = RetryPolicies.limitRetries(5), errorOrValueHandler = errorOrValueHandler ) io.unsafeRunSync() // res4: Either[String, String] = Right(value = \"got some sweet details\") Syntactic sugar The cats-retry API is also available as extension methods. You need to opt into this using an import: import retry.syntax.* Examples: // To retry until you get a value you like loadedDie.roll.retryingOnFailures( policy = RetryPolicies.limitRetries(2), valueHandler = ResultHandler.retryUntilSuccessful(_ == 6, log = ResultHandler.noop) ) val httpClient = util.FlakyHttpClient() // To retry on some or all errors httpClient.getCatGif.retryingOnErrors( policy = RetryPolicies.limitRetries(2), errorHandler = ResultHandler.retryOnAllErrors(log = ResultHandler.noop) ) // To retry on failures and some or all errors httpClient.getRecordDetails(\"foo\").retryingOnFailuresAndErrors( policy = RetryPolicies.limitRetries(2), errorOrValueHandler = errorOrValueHandler )"
    } ,    
    {
      "title": "Getting started",
      "url": "/cats-retry/docs/",
      "content": "Getting started Let’s start with a realistic example. In order to provide business value to our stakeholders, we need to download a textual description of a cat gif. Unfortunately we have to do this over a flaky network connection, so there’s a high probability it will fail. We’ll be working with the cats-effect IO monad, but any effect monad with an instance of Temporal will do. import cats.effect.IO val httpClient = util.FlakyHttpClient() val flakyRequest: IO[String] = httpClient.getCatGif To improve the chance of successfully downloading the file, let’s wrap this with some retry logic. We’ll add a dependency on the core module: val catsRetryVersion = \"4.0.0\" libraryDependencies += \"com.github.cb372\" %% \"cats-retry\" % catsRetryVersion, (Note: if you’re using Scala.js, you’ll need a %%% instead of %%.) First we’ll need a retry policy. We’ll keep it simple: retry up to 5 times, with no delay between attempts. (See the retry policies page for information on more powerful policies). import retry._ val retryFiveTimes = RetryPolicies.limitRetries[IO](5) We can also provide an error handler to do some logging each time the operation raises an error. Note how this also happens within whatever monad you’re working in, in this case the IO monad. import scala.concurrent.duration.FiniteDuration import retry.RetryDetails.NextStep._ val logMessages = collection.mutable.ArrayBuffer.empty[String] def logError(err: Throwable, details: RetryDetails): IO[Unit] = details.nextStepIfUnsuccessful match case DelayAndRetry(nextDelay: FiniteDuration) =&gt; IO(logMessages.append(s\"Failed to download. So far we have retried ${details.retriesSoFar} times.\")) case GiveUp =&gt; IO(logMessages.append(s\"Giving up after ${details.retriesSoFar} retries\")) Now we have a retry policy and an error handler, we can wrap our IO in retries. import retry.ResultHandler.retryOnAllErrors val flakyRequestWithRetry: IO[String] = retryingOnErrors(flakyRequest)( policy = retryFiveTimes, errorHandler = retryOnAllErrors(logError) ) Let’s see it in action. import cats.effect.unsafe.implicits.global flakyRequestWithRetry.unsafeRunSync() // res1: String = \"cute cat gets sleepy and falls asleep\" logMessages.foreach(println) // Failed to download. So far we have retried 0 times. // Failed to download. So far we have retried 1 times. // Failed to download. So far we have retried 2 times. // Failed to download. So far we have retried 3 times. Next steps: Learn about the other available combinators Learn about the MTL combinators Learn more about retry policies"
    } ,    
    {
      "title": "cats-retry",
      "url": "/cats-retry/",
      "content": "A library for retrying actions that can fail. Designed to work with cats and cats-effect. Inspired by the retry Haskell package. Get started with Getting started!"
    } ,      
    {
      "title": "Migration Guide",
      "url": "/cats-retry/docs/migration.html",
      "content": "cats-retry v3 -&gt; v4 Migration Guide The major changes in v4 are as follows: Scala 3. The library is now published for Scala 3 only. Cats Effect. The library is now more strongly coupled to Cats Effect. Adaption. cats-retry now supports adaptation in the face of errors or failures. Dynamic retry policies. Retry policies are now more powerful. API redesign. The API has been completely rewritten to provide more power and flexibility with fewer combinators. The following migration guide will cover each of those topics. Scala 3 cats-retry v4 is only published for Scala 3.3.x. It will work with Scala 3.3.x or newer. It might work with Scala 2.13, but it has not been tested. If you use Scala 2.13, please stick with cats-retry v3. Cats Effect In v4 we decided to embrace Cats Effect more closely in order to simplify the library. That means: the cats-retry-alleycats module is gone the Sleep type class is gone; we use CE Temporal directly Instead of an abstract error type E, the error type is now Throwable your effect monad will need to be Cats Effect IO or something similar (anything with a Temporal instance) If you use the alleycats module, please stick with cats-retry v3. Adaptation The biggest new feature in v4 is support for adaptation. Please see the adaptation docs for an explanation and a worked example. Dynamic retry policies Retry policies now have access to the result of the action, so they can dynamically change their behaviour depending on the particular failure or error that occurred. This means that RetryPolicy now has an extra type parameter. All the built-in policies set this type param to Any. Please see the retry policies docs for more details. API redesign There are now fewer combinators, and hooks such as wasSuccessful or isWorthRetrying have been replaced with a more powerful concept known as a “result handler”. For each of the combinators in cats-retry v3, we will show how to update your code when upgrading to v4. retryingM This alias for retryingOnFailures was deprecated and has been removed. Please follow the retryingOnFailures migration guide. retryingOnFailures Old: def retryingOnFailures[F[_]]( policy: RetryPolicy[F], wasSuccessful: A =&gt; F[Boolean], onFailure: (A, RetryDetails) =&gt; F[Unit] )( action: =&gt; F[A] ): F[A] New: def retryingOnFailures[F[_]: Temporal, A]( action: F[A] )( policy: RetryPolicy[F, A], valueHandler: ValueHandler[F, A] ): F[Either[A, A]] The action is now passed as the first argument, not the last. The policy can be used without any changes, assuming you have not implemented a custom retry policy. wasSuccessful and onFailure have been replaced by valueHandler. This is a function that takes the action’s result and the retry details, does any necessary logging, and decides what to do next. If your wasSuccessful is a simple predicate lifted to F using pure, then there is a helper you can use to maintain the existing behaviour: retryingOnFailures(action)( policy, valueHandler = ResultHandler.retryUntilSuccessful(predicate, log = doSomeLogging) ) Note that doSomeLogging will be invoked after every attempt, not only on failure, so it’s not exactly the same as the old onFailure hook. The result is now F[Either[A, A]]. This is to indicate whether the returned value was a success or a failure. If the operation failed, but we gave up because we exhausted our retries, then the result will be wrapped in a Left. If it’s a successful result, it will be a Right. retryingOnSomeErrors Old: def retryingOnSomeErrors[F[_], E]( policy: RetryPolicy[F], isWorthRetrying: E =&gt; F[Boolean], onError: (E, RetryDetails) =&gt; F[Unit] )( action: =&gt; F[A] ): F[A] New: def retryingOnErrors[F[_], A]( action: F[A] )( policy: RetryPolicy[F, Throwable], errorHandler: ErrorHandler[F, A] ): F[A] The error type is now hardcoded to Throwable, so the E type parameter has been removed. The action is now passed as the first argument, not the last. The policy can be used without any changes, assuming you have not implemented a custom retry policy. isWorthRetrying and onError have been replaced by errorHandler. This is a function that takes the raised error and the retry details, does any necessary logging, and decides what to do next. If your isWorthRetrying is a simple predicate lifted to F using pure, then there is a helper you can use to maintain the existing behaviour: retryingOnErrors(action)( policy, errorHandler = ResultHandler.retryOnSomeErrors(predicate, log = doSomeLogging) ) Note that doSomeLogging will be invoked every time an error is raised, not only on errors that are worth retrying, so it’s not exactly the same as the old onError hook. retryingOnAllErrors Old: def retryingOnAllErrors[F[_], E]( policy: RetryPolicy[F], onError: (E, RetryDetails) =&gt; F[Unit] )( action: =&gt; F[A] ): F[A] New: def retryingOnErrors[F[_], A]( action: F[A] )( policy: RetryPolicy[F, Throwable], errorHandler: ErrorHandler[F, A] ): F[A] The error type is now hardcoded to Throwable, so the E type parameter has been removed. The action is now passed as the first argument, not the last. The policy can be used without any changes, assuming you have not implemented a custom retry policy. onError has been replaced by errorHandler. This is a function that takes the raised error and the retry details, does any necessary logging, and decides what to do next. There is a helper you can use to maintain the existing behaviour: retryingOnErrors(action)( policy, errorHandler = ResultHandler.retryOnAllErrors(log = doSomeLogging) ) Note that doSomeLogging will be invoked every time an error is raised, so it is basically the same as the old onError hook. retryingOnFailuresAndSomeErrors Old: def retryingOnFailuresAndSomeErrors[F[_], E]( policy: RetryPolicy[F], wasSuccessful: A =&gt; F[Boolean], isWorthRetrying: E =&gt; F[Boolean], onFailure: (A, RetryDetails) =&gt; F[Unit], onError: (F, RetryDetails) =&gt; F[Unit] )( action: =&gt; F[A] ): F[A] New: def retryingOnFailuresAndErrors[F[_], A]( action: F[A] )( policy: RetryPolicy[F, Either[Throwable, A]], errorOrValueHandler: ErrorOrValueHandler[F, A] ): F[Either[A, A]] The error type is now hardcoded to Throwable, so the E type parameter has been removed. The action is now passed as the first argument, not the last. The policy can be used without any changes, assuming you have not implemented a custom retry policy. wasSuccessful, isWorthRetrying, onFailure and onError have been replaced by a single errorOrValueHandler. This is a function that takes the action’s result or the error that was raised, plus the retry details, does any necessary logging, and decides what to do next. See the retryingOnFailuresAndErrors docs for more details on how to write an ErrorOrValueHandler. The result is now F[Either[A, A]]. This is to indicate whether the returned value was a success or a failure. If the operation failed, but we gave up because we exhausted our retries, then the result will be wrapped in a Left. If it’s a successful result, it will be a Right. retryingOnFailuresAndAllErrors Old: def retryingOnFailuresAndAllErrors[F[_], E]( policy: RetryPolicy[F], wasSuccessful: A =&gt; F[Boolean], onFailure: (A, RetryDetails) =&gt; F[Unit], onError: (F, RetryDetails) =&gt; F[Unit] )( action: =&gt; F[A] ): F[A] New: def retryingOnFailuresAndErrors[F[_], A]( action: F[A] )( policy: RetryPolicy[F, Either[Throwable, A]], errorOrValueHandler: ErrorOrValueHandler[F, A] ): F[Either[A, A]] The error type is now hardcoded to Throwable, so the E type parameter has been removed. The action is now passed as the first argument, not the last. The policy can be used without any changes, assuming you have not implemented a custom retry policy. wasSuccessful, onFailure and onError have been replaced by a single errorOrValueHandler. This is a function that takes the action’s result or the error that was raised, plus the retry details, does any necessary logging, and decides what to do next. See the retryingOnFailuresAndErrors docs for more details on how to write an ErrorOrValueHandler. The result is now F[Either[A, A]]. This is to indicate whether the returned value was a success or a failure. If the operation failed, but we gave up because we exhausted our retries, then the result will be wrapped in a Left. If it’s a successful result, it will be a Right."
    } ,    
    {
      "title": "MTL Combinators",
      "url": "/cats-retry/docs/mtl-combinators.html",
      "content": "MTL Combinators The cats-retry-mtl module provides two additional retry methods that operating with errors produced by Handle from cats-mtl. Installation To use cats-retry-mtl, add the following dependency to your build.sbt: val catsRetryVersion = \"4.0.0\" libraryDependencies += \"com.github.cb372\" %% \"cats-retry-mtl\" % catsRetryVersion Interaction with cats-retry core combinators MTL retry works independently from retry.retryingOnErrors. The retry.mtl.retryingOnErrors combinator evaluates retry exclusively on errors produced by Handle. Thus errors produced in the effect monad’s error channel are not taken into account and retry is not triggered. If you want to retry in case of any error, you can chain the methods: action .retryingOnErrors(policy, exceptionHandler) .retryingOnMtlErrors[AppError](policy, mtlErrorHandler) retryingOnErrors This is useful when you are working with a Handle[M, E] and you want to retry on some or all errors. To use retryingOnErrors, you need to pass in a predicate that decides whether a given error is worth retrying. The API looks like this: def retryingOnErrors[F[_]: Temporal, A, E: Handle[F, *]]( action: F[A] )( policy: RetryPolicy[F], errorHandler: ResultHandler[F, E, A] ): F[A] The inputs are: the operation that you want to wrap with retries a retry policy, which determines the maximum number of retries and how long to delay after each attempt an error that decides whether a given error is worth retrying, and does any necessary logging Example: import retry.{HandlerDecision, ResultHandler, RetryDetails, RetryPolicies} import cats.data.EitherT import cats.effect.{Sync, IO} import cats.mtl.Handle import cats.syntax.all.* import scala.concurrent.duration.* import cats.effect.unsafe.implicits.global type Effect[A] = EitherT[IO, AppError, A] case class AppError(reason: String) def failingOperation[F[_]: [M[_]] =&gt;&gt; Handle[M, AppError]]: F[Unit] = Handle[F, AppError].raise(AppError(\"Boom!\")) def logError[F[_]: Sync](error: AppError, details: RetryDetails): F[Unit] = Sync[F].delay(println(s\"Raised error $error. Details $details\")) val effect = retry.mtl.retryingOnErrors(failingOperation[Effect])( policy = RetryPolicies.limitRetries[Effect](2), errorHandler = (error: AppError, details: RetryDetails) =&gt; logError[Effect](error, details).as( if error.reason.contains(\"Boom!\") then HandlerDecision.Continue else HandlerDecision.Stop ) ) effect .value .unsafeRunTimed(1.second) // Raised error AppError(Boom!). Details RetryDetails(0,0 days,DelayAndRetry(0 days)) // Raised error AppError(Boom!). Details RetryDetails(1,0 days,DelayAndRetry(0 days)) // Raised error AppError(Boom!). Details RetryDetails(2,0 days,GiveUp) // res1: Option[Either[AppError, Unit]] = Some( // value = Left(value = AppError(reason = \"Boom!\")) // ) Syntactic sugar The cats-retry-mtl API is also available as an extension method. You need to opt into this using an import: import retry.mtl.syntax.* Here’s an example showing how extension methods from both the core module and the MTL module can be used in combination: import retry.* import cats.data.EitherT import cats.effect.{Async, LiftIO, IO} import cats.syntax.all.* import cats.mtl.Handle import retry.mtl.syntax.* import retry.syntax.* import scala.concurrent.duration.* import cats.effect.unsafe.implicits.global case class AppError(reason: String) class Service[F[_]](client: util.FlakyHttpClient)(implicit F: Async[F], L: LiftIO[F], AH: Handle[F, AppError]) { // evaluates retry exclusively on errors produced by Handle def findCoolCatGifRetryMtl(policy: RetryPolicy[F, Any]): F[String] = findCoolCatGif.retryingOnMtlErrors[AppError](policy, logAndRetryOnAllMtlErrors) // evaluates retry on errors produced by MonadError and Handle def findCoolCatGifRetryAll(policy: RetryPolicy[F, Any]): F[String] = findCoolCatGif .retryingOnErrors(policy, logAndRetryOnAllErrors) .retryingOnMtlErrors[AppError](policy, logAndRetryOnAllMtlErrors) private def findCoolCatGif: F[String] = for { gif &lt;- L.liftIO(client.getCatGif) _ &lt;- isCoolGif(gif) } yield gif private def isCoolGif(string: String): F[Unit] = if (string.contains(\"cool\")) F.unit else AH.raise(AppError(\"Gif is not cool\")) private def logError(error: Throwable, details: RetryDetails): F[Unit] = F.delay(println(s\"Raised error $error. Details $details\")) private def logMtlError(error: AppError, details: RetryDetails): F[Unit] = F.delay(println(s\"Raised MTL error $error. Details $details\")) private val logAndRetryOnAllErrors: ErrorHandler[F, String] = (error: Throwable, details: RetryDetails) =&gt; logError(error, details).as(HandlerDecision.Continue) private val logAndRetryOnAllMtlErrors: ResultHandler[F, AppError, String] = (error: AppError, details: RetryDetails) =&gt; logMtlError(error, details).as(HandlerDecision.Continue) } type Effect[A] = EitherT[IO, AppError, A] val policy = RetryPolicies.limitRetries[Effect](5) val service = new Service[Effect](util.FlakyHttpClient()) Retrying only on MTL errors: service.findCoolCatGifRetryMtl(policy).value.attempt.unsafeRunTimed(1.second) // res3: Option[Either[Throwable, Either[AppError, String]]] = Some( // value = Left(value = java.io.IOException: Failed to download) // ) Retrying on both exceptions and MTL errors: service.findCoolCatGifRetryAll(policy).value.attempt.unsafeRunTimed(1.second) // Raised error java.io.IOException: Failed to download. Details RetryDetails(0,0 days,DelayAndRetry(0 days)) // Raised error java.io.IOException: Failed to download. Details RetryDetails(1,0 days,DelayAndRetry(0 days)) // Raised error java.io.IOException: Failed to download. Details RetryDetails(2,0 days,DelayAndRetry(0 days)) // Raised MTL error AppError(Gif is not cool). Details RetryDetails(0,0 days,DelayAndRetry(0 days)) // Raised MTL error AppError(Gif is not cool). Details RetryDetails(1,0 days,DelayAndRetry(0 days)) // Raised MTL error AppError(Gif is not cool). Details RetryDetails(2,0 days,DelayAndRetry(0 days)) // Raised MTL error AppError(Gif is not cool). Details RetryDetails(3,0 days,DelayAndRetry(0 days)) // Raised MTL error AppError(Gif is not cool). Details RetryDetails(4,0 days,DelayAndRetry(0 days)) // Raised MTL error AppError(Gif is not cool). Details RetryDetails(5,0 days,GiveUp) // res4: Option[Either[Throwable, Either[AppError, String]]] = Some( // value = Right(value = Left(value = AppError(reason = \"Gif is not cool\"))) // )"
    } ,    
    {
      "title": "Retry policies",
      "url": "/cats-retry/docs/policies.html",
      "content": "Retry policies A retry policy is a function that takes as input: the result of the last execution of the action, which might be a value or an error a RetryStatus containing details of the retries and delays so far and returns a PolicyDecision in a monoidal context: case class RetryPolicy[F[_], Res]( decideNextRetry: (Res, RetryStatus) =&gt; F[PolicyDecision] ) The policy decision can be one of two things: we should delay for some amount of time, possibly zero, and then retry we should stop retrying and give up Built-in policies There are a number of policies available in retry.RetryPolicies, including: constantDelay (retry forever, with a fixed delay between retries) limitRetries (retry up to N times, with no delay between retries) exponentialBackoff (double the delay after each retry) fibonacciBackoff (delay(n) = (delay(n - 2) + delay(n - 1)) fullJitter (randomised exponential backoff) All of these are “static” policies, in the sense that they ignore the result of the last attempt and decide what to do based only on the RetryStatus. Dynamic policies In general we recommend using combinations of the built-in static policies to build your retry policy, and only inspecting the action’s result in the result handler. This separation of concerns, keeping the retry policy simple and encapsulating all the dynamic logic in the result handler, makes your retry logic easy to reason about. However, there are use scenarios where you need a more powerful retry policy. For example, you might want to use a short constant delay for most errors, but switch to exponential backoff when your requests to another service are throttled. You can build a dynamic policy like this using RetryPolicies.dynamic: val policy = dynamic[IO, Throwable] { case _: ProvisionedThroughputExceeded =&gt; exponentialBackoff(500.millis) case _ =&gt; constantDelay(100.millis) } Policy transformers There are also a few combinators to transform policies, including: capDelay (set an upper bound on the delay between retries) limitRetriesByDelay (give up when the delay between retries reaches a certain limit) limitRetriesByCumulativeDelay (give up when the total delay reaches a certain limit) Composing policies cats-retry offers several ways of composing policies together. join First up is the join operation, it has the following semantics: If either of the policies wants to give up, the combined policy gives up. If both policies want to delay and retry, the longer of the two delays is chosen. This way of combining policies implies: That combining two identical policies result in this same policy. That the order you combine policies doesn’t affect the resulted policy. That is to say, join is associative, commutative and idempotent, which makes it a Semilattice. Furthermore, it also forms a BoundedSemilattice, as there is also a neutral element for combining with join, which is a simple policy that retries with no delay and never gives up. This makes it very useful for combining two policies with a lower bounded delay. For an example of composing policies like this, we can use join to create a policy that retries up to 5 times, starting with a 10 ms delay and increasing exponentially: import cats.* import cats.effect.IO import cats.syntax.all.* import scala.concurrent.duration.* import retry.RetryPolicy import retry.RetryPolicies.* val policy = limitRetries[IO](5) join exponentialBackoff[IO](10.milliseconds) meet The next operation is meet, it is the dual of join and has the following semantics: If both of the policies wants to give up, the combined policy gives up. If both policies want to delay and retry, the shorter of the two delays is chosen. Just like join, meet is also associative, commutative and idempotent, which implies: That combining two identical policies result in this same policy. That the order you combine policies doesn’t affect the resulted policy. You can use meet to compose policies where you want an upper bound on the delay. As an example the capDelay combinator is implemented using meet: def capDelay[F[_]: Applicative, Res]( cap: FiniteDuration, policy: RetryPolicy[F, Res] ): RetryPolicy[F, Res] = policy.meet(constantDelay(cap)) val neverAbove5Minutes = capDelay(5.minutes, exponentialBackoff[IO](10.milliseconds)) Retry policies form a distributive lattice, as meet and join both distribute over each other. As we feel that the join operation is more common, we use it as the canonical BoundedSemilattice instance found in the companion object. This means you can use it with the standard Cats semigroup syntax like this: limitRetries[IO](5) |+| constantDelay[IO](100.milliseconds) followedBy There is also an operator followedBy to sequentially compose policies, i.e. if the first one wants to give up, use the second one. As an example, we can retry with a 100ms delay 5 times and then retry every minute: val retry5times100millis = constantDelay[IO](100.millis) |+| limitRetries[IO](5) retry5times100millis.followedBy(constantDelay[IO](1.minute)) followedBy is an associative operation and forms a Monoid with a policy that always gives up as its identity: // This is equal to just calling constantDelay[IO](200.millis) constantDelay[IO](200.millis).followedBy(alwaysGiveUp) Currently we don’t provide such an instance, as it would clash with the BoundedSemilattice instance described earlier. mapDelay, flatMapDelay The mapDelay and flatMapDelay operators work just like map and flatMap, but allow you to map on the FiniteDuration that represents the retry delay. As a simple example, it allows us to add a specific delay of 10ms on top of an existing policy: fibonacciBackoff[IO](200.millis).mapDelay(_ + 10.millis) Furthermore, flatMapDelay also allows us to depend on certain effects to evaluate how to modify the delay: def determineDelay: IO[FiniteDuration] = ??? fibonacciBackoff[IO](200.millis).flatMapDelay { currentDelay =&gt; if (currentDelay &lt; 500.millis) currentDelay.pure[IO] else determineDelay } mapK If you’ve defined a RetryPolicy[F], but you need a RetryPolicy for another effect type G[_], you can use mapK to convert from one to the other. For example, you might have defined a custom RetryPolicy[cats.effect.IO] and for another part of the app you might need a RetryPolicy[Kleisli[IO]]: import cats.effect.LiftIO import cats.data.Kleisli val customPolicy: RetryPolicy[IO, Any] = limitRetries[IO](5).join(constantDelay[IO](100.milliseconds)) customPolicy.mapK[Kleisli[IO, String, *]](LiftIO.liftK[Kleisli[IO, String, *]]) Writing your own policy The easiest way to define a custom retry policy is to use RetryPolicy.lift, specifying the monad you need to work in: import retry.{RetryPolicy, PolicyDecision} import java.time.{LocalDate, DayOfWeek} val onlyRetryOnTuesdays = RetryPolicy.lift[IO, Any] { (_, _) =&gt; if (LocalDate.now().getDayOfWeek() == DayOfWeek.TUESDAY) { PolicyDecision.DelayAndRetry(delay = 100.milliseconds) } else { PolicyDecision.GiveUp } }"
    } ,      
  ];

  idx = lunr(function () {
    this.ref("title");
    this.field("content");

    docs.forEach(function (doc) {
      this.add(doc);
    }, this);
  });

  docs.forEach(function (doc) {
    docMap.set(doc.title, doc.url);
  });
}

// The onkeypress handler for search functionality
function searchOnKeyDown(e) {
  const keyCode = e.keyCode;
  const parent = e.target.parentElement;
  const isSearchBar = e.target.id === "search-bar";
  const isSearchResult = parent ? parent.id.startsWith("result-") : false;
  const isSearchBarOrResult = isSearchBar || isSearchResult;

  if (keyCode === 40 && isSearchBarOrResult) {
    // On 'down', try to navigate down the search results
    e.preventDefault();
    e.stopPropagation();
    selectDown(e);
  } else if (keyCode === 38 && isSearchBarOrResult) {
    // On 'up', try to navigate up the search results
    e.preventDefault();
    e.stopPropagation();
    selectUp(e);
  } else if (keyCode === 27 && isSearchBarOrResult) {
    // On 'ESC', close the search dropdown
    e.preventDefault();
    e.stopPropagation();
    closeDropdownSearch(e);
  }
}

// Search is only done on key-up so that the search terms are properly propagated
function searchOnKeyUp(e) {
  // Filter out up, down, esc keys
  const keyCode = e.keyCode;
  const cannotBe = [40, 38, 27];
  const isSearchBar = e.target.id === "search-bar";
  const keyIsNotWrong = !cannotBe.includes(keyCode);
  if (isSearchBar && keyIsNotWrong) {
    // Try to run a search
    runSearch(e);
  }
}

// Move the cursor up the search list
function selectUp(e) {
  if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index) && (index > 0)) {
      const nextIndexStr = "result-" + (index - 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Move the cursor down the search list
function selectDown(e) {
  if (e.target.id === "search-bar") {
    const firstResult = document.querySelector("li[id$='result-0']");
    if (firstResult) {
      firstResult.firstChild.focus();
    }
  } else if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index)) {
      const nextIndexStr = "result-" + (index + 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Search for whatever the user has typed so far
function runSearch(e) {
  if (e.target.value === "") {
    // On empty string, remove all search results
    // Otherwise this may show all results as everything is a "match"
    applySearchResults([]);
  } else {
    const tokens = e.target.value.split(" ");
    const moddedTokens = tokens.map(function (token) {
      // "*" + token + "*"
      return token;
    })
    const searchTerm = moddedTokens.join(" ");
    const searchResults = idx.search(searchTerm);
    const mapResults = searchResults.map(function (result) {
      const resultUrl = docMap.get(result.ref);
      return { name: result.ref, url: resultUrl };
    })

    applySearchResults(mapResults);
  }

}

// After a search, modify the search dropdown to contain the search results
function applySearchResults(results) {
  const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
  if (dropdown) {
    //Remove each child
    while (dropdown.firstChild) {
      dropdown.removeChild(dropdown.firstChild);
    }

    //Add each result as an element in the list
    results.forEach(function (result, i) {
      const elem = document.createElement("li");
      elem.setAttribute("class", "dropdown-item");
      elem.setAttribute("id", "result-" + i);

      const elemLink = document.createElement("a");
      elemLink.setAttribute("title", result.name);
      elemLink.setAttribute("href", result.url);
      elemLink.setAttribute("class", "dropdown-item-link");

      const elemLinkText = document.createElement("span");
      elemLinkText.setAttribute("class", "dropdown-item-link-text");
      elemLinkText.innerHTML = result.name;

      elemLink.appendChild(elemLinkText);
      elem.appendChild(elemLink);
      dropdown.appendChild(elem);
    });
  }
}

// Close the dropdown if the user clicks (only) outside of it
function closeDropdownSearch(e) {
  // Check if where we're clicking is the search dropdown
  if (e.target.id !== "search-bar") {
    const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
    if (dropdown) {
      dropdown.classList.remove("show");
      document.documentElement.removeEventListener("click", closeDropdownSearch);
    }
  }
}
